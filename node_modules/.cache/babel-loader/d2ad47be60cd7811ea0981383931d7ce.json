{"ast":null,"code":"export function createTrackingData(reaction) {\n  var trackingData = {\n    cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS,\n    reaction: reaction\n  };\n  return trackingData;\n}\n/**\n * The minimum time before we'll clean up a Reaction created in a render\n * for a component that hasn't managed to run its effects. This needs to\n * be big enough to ensure that a component won't turn up and have its\n * effects run without being re-rendered.\n */\n\nexport var CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10000;\n/**\n * The frequency with which we'll check for leaked reactions.\n */\n\nexport var CLEANUP_TIMER_LOOP_MILLIS = 10000;\n/**\n * Reactions created by components that have yet to be fully mounted.\n */\n\nvar uncommittedReactionRefs = new Set();\n/**\n * Latest 'uncommitted reactions' cleanup timer handle.\n */\n\nvar reactionCleanupHandle;\n\nfunction ensureCleanupTimerRunning() {\n  if (reactionCleanupHandle === undefined) {\n    reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS);\n  }\n}\n\nexport function scheduleCleanupOfReactionIfLeaked(ref) {\n  uncommittedReactionRefs.add(ref);\n  ensureCleanupTimerRunning();\n}\nexport function recordReactionAsCommitted(reactionRef) {\n  uncommittedReactionRefs.delete(reactionRef);\n}\n/**\n * Run by the cleanup timer to dispose any outstanding reactions\n */\n\nfunction cleanUncommittedReactions() {\n  reactionCleanupHandle = undefined; // Loop through all the candidate leaked reactions; those older\n  // than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.\n\n  var now = Date.now();\n  uncommittedReactionRefs.forEach(function (ref) {\n    var tracking = ref.current;\n\n    if (tracking) {\n      if (now >= tracking.cleanAt) {\n        // It's time to tidy up this leaked reaction.\n        tracking.reaction.dispose();\n        ref.current = null;\n        uncommittedReactionRefs.delete(ref);\n      }\n    }\n  });\n\n  if (uncommittedReactionRefs.size > 0) {\n    // We've just finished a round of cleanups but there are still\n    // some leak candidates outstanding.\n    ensureCleanupTimerRunning();\n  }\n}\n/* istanbul ignore next */\n\n/**\n * Only to be used by test functions; do not export outside of mobx-react-lite\n */\n\n\nexport function forceCleanupTimerToRunNowForTests() {\n  // This allows us to control the execution of the cleanup timer\n  // to force it to run at awkward times in unit tests.\n  if (reactionCleanupHandle) {\n    clearTimeout(reactionCleanupHandle);\n    cleanUncommittedReactions();\n  }\n}\n/* istanbul ignore next */\n\nexport function resetCleanupScheduleForTests() {\n  if (reactionCleanupHandle) {\n    clearTimeout(reactionCleanupHandle);\n    reactionCleanupHandle = undefined;\n  }\n\n  uncommittedReactionRefs.clear();\n}","map":{"version":3,"sources":["/Users/awang/Downloads/react/key/keyCode/node_modules/mobx-react-lite/es/reactionCleanupTracking.js"],"names":["createTrackingData","reaction","trackingData","cleanAt","Date","now","CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS","CLEANUP_TIMER_LOOP_MILLIS","uncommittedReactionRefs","Set","reactionCleanupHandle","ensureCleanupTimerRunning","undefined","setTimeout","cleanUncommittedReactions","scheduleCleanupOfReactionIfLeaked","ref","add","recordReactionAsCommitted","reactionRef","delete","forEach","tracking","current","dispose","size","forceCleanupTimerToRunNowForTests","clearTimeout","resetCleanupScheduleForTests","clear"],"mappings":"AAAA,OAAO,SAASA,kBAAT,CAA4BC,QAA5B,EAAsC;AACzC,MAAIC,YAAY,GAAG;AACfC,IAAAA,OAAO,EAAEC,IAAI,CAACC,GAAL,KAAaC,qCADP;AAEfL,IAAAA,QAAQ,EAAEA;AAFK,GAAnB;AAIA,SAAOC,YAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAII,qCAAqC,GAAG,KAA5C;AACP;AACA;AACA;;AACA,OAAO,IAAIC,yBAAyB,GAAG,KAAhC;AACP;AACA;AACA;;AACA,IAAIC,uBAAuB,GAAG,IAAIC,GAAJ,EAA9B;AACA;AACA;AACA;;AACA,IAAIC,qBAAJ;;AACA,SAASC,yBAAT,GAAqC;AACjC,MAAID,qBAAqB,KAAKE,SAA9B,EAAyC;AACrCF,IAAAA,qBAAqB,GAAGG,UAAU,CAACC,yBAAD,EAA4BP,yBAA5B,CAAlC;AACH;AACJ;;AACD,OAAO,SAASQ,iCAAT,CAA2CC,GAA3C,EAAgD;AACnDR,EAAAA,uBAAuB,CAACS,GAAxB,CAA4BD,GAA5B;AACAL,EAAAA,yBAAyB;AAC5B;AACD,OAAO,SAASO,yBAAT,CAAmCC,WAAnC,EAAgD;AACnDX,EAAAA,uBAAuB,CAACY,MAAxB,CAA+BD,WAA/B;AACH;AACD;AACA;AACA;;AACA,SAASL,yBAAT,GAAqC;AACjCJ,EAAAA,qBAAqB,GAAGE,SAAxB,CADiC,CAEjC;AACA;;AACA,MAAIP,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAV;AACAG,EAAAA,uBAAuB,CAACa,OAAxB,CAAgC,UAAUL,GAAV,EAAe;AAC3C,QAAIM,QAAQ,GAAGN,GAAG,CAACO,OAAnB;;AACA,QAAID,QAAJ,EAAc;AACV,UAAIjB,GAAG,IAAIiB,QAAQ,CAACnB,OAApB,EAA6B;AACzB;AACAmB,QAAAA,QAAQ,CAACrB,QAAT,CAAkBuB,OAAlB;AACAR,QAAAA,GAAG,CAACO,OAAJ,GAAc,IAAd;AACAf,QAAAA,uBAAuB,CAACY,MAAxB,CAA+BJ,GAA/B;AACH;AACJ;AACJ,GAVD;;AAWA,MAAIR,uBAAuB,CAACiB,IAAxB,GAA+B,CAAnC,EAAsC;AAClC;AACA;AACAd,IAAAA,yBAAyB;AAC5B;AACJ;AACD;;AACA;AACA;AACA;;;AACA,OAAO,SAASe,iCAAT,GAA6C;AAChD;AACA;AACA,MAAIhB,qBAAJ,EAA2B;AACvBiB,IAAAA,YAAY,CAACjB,qBAAD,CAAZ;AACAI,IAAAA,yBAAyB;AAC5B;AACJ;AACD;;AACA,OAAO,SAASc,4BAAT,GAAwC;AAC3C,MAAIlB,qBAAJ,EAA2B;AACvBiB,IAAAA,YAAY,CAACjB,qBAAD,CAAZ;AACAA,IAAAA,qBAAqB,GAAGE,SAAxB;AACH;;AACDJ,EAAAA,uBAAuB,CAACqB,KAAxB;AACH","sourcesContent":["export function createTrackingData(reaction) {\n    var trackingData = {\n        cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS,\n        reaction: reaction\n    };\n    return trackingData;\n}\n/**\n * The minimum time before we'll clean up a Reaction created in a render\n * for a component that hasn't managed to run its effects. This needs to\n * be big enough to ensure that a component won't turn up and have its\n * effects run without being re-rendered.\n */\nexport var CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10000;\n/**\n * The frequency with which we'll check for leaked reactions.\n */\nexport var CLEANUP_TIMER_LOOP_MILLIS = 10000;\n/**\n * Reactions created by components that have yet to be fully mounted.\n */\nvar uncommittedReactionRefs = new Set();\n/**\n * Latest 'uncommitted reactions' cleanup timer handle.\n */\nvar reactionCleanupHandle;\nfunction ensureCleanupTimerRunning() {\n    if (reactionCleanupHandle === undefined) {\n        reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS);\n    }\n}\nexport function scheduleCleanupOfReactionIfLeaked(ref) {\n    uncommittedReactionRefs.add(ref);\n    ensureCleanupTimerRunning();\n}\nexport function recordReactionAsCommitted(reactionRef) {\n    uncommittedReactionRefs.delete(reactionRef);\n}\n/**\n * Run by the cleanup timer to dispose any outstanding reactions\n */\nfunction cleanUncommittedReactions() {\n    reactionCleanupHandle = undefined;\n    // Loop through all the candidate leaked reactions; those older\n    // than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.\n    var now = Date.now();\n    uncommittedReactionRefs.forEach(function (ref) {\n        var tracking = ref.current;\n        if (tracking) {\n            if (now >= tracking.cleanAt) {\n                // It's time to tidy up this leaked reaction.\n                tracking.reaction.dispose();\n                ref.current = null;\n                uncommittedReactionRefs.delete(ref);\n            }\n        }\n    });\n    if (uncommittedReactionRefs.size > 0) {\n        // We've just finished a round of cleanups but there are still\n        // some leak candidates outstanding.\n        ensureCleanupTimerRunning();\n    }\n}\n/* istanbul ignore next */\n/**\n * Only to be used by test functions; do not export outside of mobx-react-lite\n */\nexport function forceCleanupTimerToRunNowForTests() {\n    // This allows us to control the execution of the cleanup timer\n    // to force it to run at awkward times in unit tests.\n    if (reactionCleanupHandle) {\n        clearTimeout(reactionCleanupHandle);\n        cleanUncommittedReactions();\n    }\n}\n/* istanbul ignore next */\nexport function resetCleanupScheduleForTests() {\n    if (reactionCleanupHandle) {\n        clearTimeout(reactionCleanupHandle);\n        reactionCleanupHandle = undefined;\n    }\n    uncommittedReactionRefs.clear();\n}\n"]},"metadata":{},"sourceType":"module"}